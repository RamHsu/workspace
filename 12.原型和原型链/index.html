<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>

<script>
    var a = null;
    var b = [];

    // console.log(typeof a); // object
    // console.log(typeof b); // object

    // 使用 instanceof 判断一个函数是否是一个变量的构造函数
    // console.log(b instanceof Array); // true

    // console.log(Array.prototype); // 所有的构造函数都有一个prototype(显示原型属性)
    // console.log(b.__proto__); // 所有的引用类型（数组、对象、函数）都有一个 _proto_ 属性(隐式原型属性），属性值是一个普通的对象


    function Person(name, age) {
        this.name = name;
        this.age = age;
    }
    Person.prototype.say = function () {
        console.log("My name is " + this.name + ", I am " + this.age + " years old.");
    }

    // var p = new Person("Sam", 24);

    function Student(name, age, major) {
        Person.call(this, name, age);
        this.major = major;
    }
    Person.prototype.sayMore = function () {
        console.log("My mahor is " + this.major + ".");
    }

    // 类的继承
    // Student.prototype = Object.create(p); // 这一步会造成Student实例中的constructor的丢失
    Student.prototype = Object.create(Person.prototype); // 这一步会造成Student实例中的constructor的丢失

    // 重新指定constructor
    Student.prototype.constructor = Student; // 恢复Student实例中的constructor的丢失

    // console.log(Student.prototype.constructor === Student);

    var s = new Student("Ram Hsu", 25, "Web");
    // console.log(s);

    // console.log(s.__proto__);
    // console.log(s.__proto__.__proto__);

    // s.say();
    // s.sayMore();
    // console.log(s instanceof Student); // true
    // console.log(s instanceof Person); // true
</script>